### 2. 서버가 시작하는 시점에 부모 ApplicationContext와 자식 ApplicationContext가 초기화되는 과정에 대해 구체적으로 설명해라.
* 서버가 시작되면 리스너가 우선적으로 실행된다. 이 때 스프링 프레임워크인 org.springframework.web.context.ContextLoaderListener를 리스너로 등록해 두었기 떄문에 이 컨텍스트 로더 리스너가 실행된다. 이에 따라 context로 디폴트 지정되어 있는 applicationContext.xml 이름의 xml을 클래스패스에 생성해놓았기 때문에 이 context를 읽게 된다. 이외에도 param-value에 다른 설정 파일들을 허용 가능하다. 
 기본적으로 생성되는 루트 어플리케이션 컨텍스트를 부모로 하고, 이를 상속받은 자식 컨텍스트들을 만들 수 있다. 부모가 먼저 초기화 되어야 자식들을 초기화 할 수 있다. 루트 어플리케이션 컨텍스트가 먼저 만들어지지 않으면 자식 컨텍스트가 빈을 찾다가 없을 때 부모를 검색해야할 때, 부모가 만들어지지 않았을 경우 에러가 발생할 수 있기 때문이다. 

### 3. 서버 시작 후 http://localhost:8080으로 접근해서 질문 목록이 보이기까지 흐름에 대해 최대한 구체적으로 설명하라. 
* 서버를 시작하면 web.xml을 읽어들인다. web.xml이 배포서술자로서 가장 기본적인 프로젝트 설정이 되어있기 때문이다. 이 xml안에서 등록된 listener와 filter를 따라 흐름이 처리된다. listener에서는 applicationContext.xml을 읽어들여서 DB 정보를 입력하고 빈으로 등록한다. 트랜잭션 매니저, 디비 이니셜라이저 등 등록된 나머지 빈들도 등록한다.
 그리고 필터를 따라 리퀘스트가 처리된다. 인코딩 필터라는 이름으로 등록된 필터를 설정된 대로 처리하고 mapping 시킨다. 매핑된 정보에 따르면 모든 url 패턴은 해당 필터를 거쳐야한다. hiddenHttpmethodFilter를 등록한다. 매핑된 이름에 따라 서블릿 이름을 등록하는데 next로 등록되어 있다. 이 서블릿은 마지막에 등록되는 서블릿 이름과 동일하다. 
  마지막으로 next라는 이름을 가진 서블릿이 등록되고, 이는 dispatcherServlet 프레임워크를 이용한다. url패턴에 따라 모든 주소는 반드시 디스패쳐 서블릿에 등록된대로 흐름에 따라 처리될 수 밖에 없다. 

localhost:8080으로 접속했다. 이에 따라 디스패쳐 서블릿에서는 리퀘스트 매핑을 한다. questionController class의 리퀘스트 매핑이 ""도 받아서 해당 컨트롤러로 넘겨지고, 컨트롤러안의 list()메소드가 ""를 받기 때문에 return "qna/list"에 의해서 /qna/list.jsp파일을 뷰로 돌려준다. prefix, suffix는 next-servlet.xml에서 설정되어 있다. 이것을 다시 디스패쳐 서블릿이 뷰를 만들어서 내보낸다. 그러면 다시 필터를 역순으로 거쳐서 브라우저에 내보내진다고 한다. 

### 9. UserService와 QnaService 중 multi thread에서 문제가 발생할 가능성이 있는 소스는 무엇이며, 그 이유는 무엇인가?
* 